\chapter{Related Work}
\label{cha:relatedwork}

The following chapter covers the most significant concepts required to comprehend this thesis's approach. It includes a closer look at decentralized communication protocols, identifier standards, and social networks that implement them. The revision and structuring of these concepts allow us to understand, build upon, and apply them to address our identified research questions. 

Between 2014 and 2018, the Social Web Working Group (SocialWG) from the W3C embarked on the journey to bring social-networking standards to the Web. This journey included defining technical protocols, vocabularies, and APIs focusing on social interactions. In addition, systems implementing these features should be able to communicate with each other in a decentralized manner. These four years resulted in several W3C Recommendations, including a collection of standards that enable various aspects of decentralized social interaction on the Web\cite{celik_prodromou_le_hors_2014}. 

\section{ActivityStreams 2.0}\label{section:activity_streams}

To be able to describe what a social activity is, it is essential to be able to describe an Activity. One of the standards of the SocialWG is ActivityStreams 2.0\footnote{https://www.w3.org/TR/activitystreams-core/}. This standard provides a model for representing \emph{Activities} using a JSON-based syntax and a vocabulary that includes all the standard terms needed to represent social activities \cite{snell_prodromou_2017}. ActivityStreams describes an activity following a story of \emph{an actor performing an action on an object} and specifies different types of actors, activities, and objects, as shown in \autoref{table:activitystreams_vocabulary}. Each of these objects can be represented as a JSON object, creating a solid foundation on which other protocols can build. 

\begin{table}[!ht]
  \centering
  \begin{tabular}{|p{4cm}|p{4cm}|p{4cm}| }
    \hline
    \multicolumn{3}{|c|}{ActivityStreams Vocabulary} \\
    \hline
    Activity types & Actor types & Object types \\
    \hline
      Accept, Add & Application & Note \\
      Announce, Arrive & Group & Document \\ 
      Block, Create & Organization & Image \\
      Delete, Dislike & Person & Article \\
      Flag, Follow & Service & Profile \\
      Ignore, Invite & & Audio \\
      Join, Leave & & Event \\
      Like, Listen & & Tombstone \\
      etc... & & etc... \\
    \hline
  \end{tabular}
  \caption{ActivityStreams 2.0 vocabulary examples}
  \label{table:activitystreams_vocabulary}
\end{table}

ActivityStreams 2.0 builds on top of its predecessor, the 1.0 version, and it has improved it in more than one perspective. One of these is the compatibility with JSON-LD\footnote{https://www.w3.org/TR/json-ld/}, which is a JSON serialization for \emph{Linked Data}\footnote{https://www.w3.org/DesignIssues/LinkedData.html}. With JSON-LD, ActivityStreams 2.0 can define its own context and define the terms that will be used inside this context. Figure \ref{fig:activitystream_example} shows an example of a JSON-LD serialized ActivityStreams 2.0 activity. 

\lstset{style=JSONStyle}
\begin{lstlisting}[language=PHP, caption=Example of activity \cite{snell_prodromou_2017}, label=fig:activitystream_example, float=h]
  {
    "@context": "https://www.w3.org/ns/activitystreams",
    "summary": "Alice created an image",
    "type": "Create",
    "actor": "http://www.test.example/Alice",
    "object": "http://example.org/foo.jpg"
  }
\end{lstlisting}


\section{ActivityPub}

ActivityPub is another W3C Recommendation that originated from the SocialWG. It is a decentralized social networking protocol that uses the syntax and vocabulary of ActivityStreams 2.0. It provides a client-to-server API, which covers the requirements of a Social API\cite{guy_2017}, i.e., publishing, subscribing, reading content, and notifying when content gets created. In addition, it provides a server-to-server API that enables decentralized, specifically, federated communication. The way ActivityPub works is the following. A user of a social network that implements this standard has its JSON-LD-based profile \ref{fig:actor_object}, which is the actor object specified before in \autoref{section:activity_streams}. ActivityPub added to this actor object two endpoints, namely, the inbox and the outbox, which represent how the actor gets and sends messages from other users. For example, when a user wants to share a post, it makes an HTTP POST request to its outbox with the respective activity object. After this, other users interested in seeing this user's posts can make an HTTP GET request to the user's outbox and retrieve all his public posts. In the case of a private message, such as user \emph{A} wanting to send a message to user \emph{B}, the same workflow would occur. User \emph{A} posts his message to his outbox, and then the activityPub server of \emph{A} will go ahead and look for the inbox of \emph{B} to make an HTTP POST request. Following this, \emph{B} makes an HTTP GET request to his inbox to retrieve all the posts addressed to him \cite{lemmer-webber_tallon_guy_prodromou_2018}. Figure \ref{fig:ap_flow} illustrates the functioning of ActivityPub. 

\lstset{style=JSONStyle}
\begin{lstlisting}[language=PHP, caption=Actor object example in ActivityPub \cite{lemmer-webber_tallon_guy_prodromou_2018}, label=fig:actor_object, float=h!]

  {
    "@context": "https://www.w3.org/ns/activitystreams",
    "type": "Person",
    "id": "https://social.example/alice/",
    "name": "Alice P.",
    "preferredUsername": "alice",
    "summary": "TU Berlin student",
    "inbox": "https://social.example/alice/inbox/",
    "outbox": "https://social.example/alice/outbox/",
    "followers": "https://social.example/alice/followers/",
    "following": "https://social.example/alice/following/",
    "liked": "https://social.example/alice/liked/"
  }
  
\end{lstlisting}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{related_work/ActivityPub-tutorial-image.png}
  \caption{ActivityPub overview \cite{lemmer-webber_tallon_guy_prodromou_2018}}
  \label{fig:ap_flow}
\end{figure}

Regarding security, ActivityPub's specification does not define any official security mechanisms to ensure confidentiality, non-repudiation, message integrity, authentication, or authorization \cite{lemmer-webber_tallon_guy_prodromou_2018}. It recommends using HTTPS for its HTTP-based communication, relying on third-party certificate authorities to provide confidentiality. Nonetheless, other security aspects remain unaddressed. Although not included in ActivityPub, the SocialWG published a list of best security practices\footnote{https://www.w3.org/wiki/SocialCG/ActivityPub/Authentication\_Authorization}. This list suggests using standards like OAuth 2.0\footnote{https://oauth.net/2/} for client-to-server authentication, as well as HTTP Signatures\footnote{https://tools.ietf.org/html/draft-cavage-http-signatures-08} and Linked Data Signatures\footnote{https://w3c-dvcg.github.io/ld-signatures/} for server-to-server authentication.

HTTP signatures are a strong option that involves asymmetric keypairs for the actors, however it is exclusive for HTTP protocol.


\section{Mastodon}
\subsection{Definition}
In today's most popular social networks like Facebook, Twitter, or Youtube, a centralized architecture keeps millions of users on one platform. Control, decision-making, user data, and censorship depend on a single profit-driven organization. On the contrary, Mastodon is a decentralized microblogging social network created to bring social networking back into the hands of its users. When switching apps and services every few years and having friends on a dozen different chat applications was a standard in terms of social networking, the German founder envisioned something that could end this, and \emph{last forever} \cite{tilley_2018}. Today, Mastodon is a network of more than 3,500 communities. Each is operated by different individuals and organizations that implement their own policies, codes of conduct, and discussion topics. By means of this,  the user has the opportunity to choose whichever instance he finds the most fitting.
Mastodon takes a significant share in the Fediverse. A single interoperable ecosystem of different social networks that can communicate with each other. In other words, it is a collection of federated social networks running on free open software on thousands of servers across the world that implement the same protocol in order to be able to interact with each other. The Fediverse is developed by a community of people around the globe independent of any corporation or official institution. It is not profit-driven, and it gives users the freedom to choose which service and instance of the Fediverse to register. On top of that, you are free to run your own instance with your own policies and allow other users to join \cite{holloway_2018}. The range of services that can be found inside the Fediverse includes blogging, microblogging, video streaming, photo, music sharing as well as file hosting. Since its standardization, ActivityPub has been widely adopted in the Fediverse, being today the dominant protocol.

After ActivityPub was published as a Recommendation by the Social Web Working Group of the W3C in January 2018, Mastodon decided to switch from its prior and pioneered the use of ActivityPub on a large scale. Promoting this way, its adoption.

Mastodon is a DOSN with microblogging features, where each server runs open source software. The basic aim of the project, which dates to 2016, is to restore control of the content distribution channels to the people by avoiding the insertion of sponsored users or posts in the feeds. From an architectural viewpoint, the platform follows a federated architecture organized into two layers implementing the ActivityPub protocol,1 as shown in Fig.1. The ActivityPub protocol allows it both to manage the communications (black links) among the servers – instances – comprising the federation and to offer a client-to-server interface which enables interactions (blue links) among the users having their accounts on the instances. In the server-to-server layer the instances form a network, and each of them administrates its 1https://www.w3.org/TR/activitypub/ Instance 1 Instance 2 Instance 3 Instance 4 User1@Instance4 User1@Instance3 User3@Instance1 User2@Instance1 User1@Instance1 Fig. 1. The decentralized architecture of Mastodon. We distinguish between two layers: the server-to-server layer, made up of interconnected (black links) instances (InstanceN); and the social network layer, formed by the ’follow’ relationships (blue links) between users (UserK@InstanceN) hosted (dotted cyan links) by the different instances. own rules, account privileges, and whether or not to share messages coming to and from other instances. Each server hosts individual user accounts, the content they produce, and the content they subscribe to. From a user experience viewpoint, Mastodon releases the major features of a microblogging platform: • users can follow one another, whether or not they are hosted on the same instance; • users can post short messages consisting of up to 500 text characters, called ’toots’, for others to read. • toots are aggregated in local and federated timelines. The former show messages from users hosted on a specific instance, while the latter aggregate the messages across all participating Mastodon instances. • users have control over the visibility of their posts. They can choose whether the post can be displayed on the federated timeline, on the timelines of the user’s followers only, or on the timeline of the users mentioned in the toot. Mastodon differs from other commercial microblogging platforms w.r.t. two key points. First, it is oriented towards small communities and community-based services. In fact, each instance may support and favor specific topics. So prior to registration, a user is encouraged to choose the instance better suited to her own tastes. Second, the Mastodon platform does not provide any algorithm for recommending new friends or promoted contents. So, the only way to establish a connection or consume a content is by searching an already known account through the search functions or by exploring the feeds of the instances in search of users with similar interests or interesting posts. These two characteristics are fundamental for the study of the interplay between the physical layer of a decentralized social network and its overlaid social network, since: (i) the coupling server/topic affects how people are distributed on the servers set and how they interact among themselves, this is true because it is well-known that common interests shape the structure of social networks [7], [8]; (ii) the lack of recommendation systems removes different external factors – often hidden by recommendation algorithms – from the mechanisms driving the formation of new links [9], [10].

process and the decentralized organization of the instance might be one of the few factors affecting the choice of who to “follow”.

\subsection{Discovery}

\cite{nottingham_2019}
As per documentation, Mastodon implements the following 4 different well-known endpoints: 

% \subsubsection{Change password}
% This endpoint origins form the proposal of the Web Application Security Working Group (WebAppSec) from the W3C, whose main mission is to provide security and policy frameworks to increase web application security and enable safe cross-site communication (https://www.w3.org/groups/wg/). It defines a well-known URL that sites can use to make their change password forms discoverable by tools. This URL would enable software, specially password managers, to easily redirect users to the right link for them to change their password.

% \subsubsection{NodeInfo}
% NodeInfo is an initiative to standardize the presentation of metadata about a server operating one of the distributed social networks. The two main aims are to get greater insights into the distributed social networking user base and to provide tools that allow users to select the most suited software and server for their requirements. Mastodon is one of the implementers of this protocol, along with other federated social networks such as Diaspora, Peertube and Wordpress [http://nodeinfo.diaspora.software/ ]. NodeInfo specifies that servers must provide the well-known path /.well-known/nodeinfo and provide a JRD document referencing the supported documents via Link elements, as shown in \label{NodeInfo response example}. [http://nodeinfo.diaspora.software/protocol.html ] Accessing the hypertext reference from the JRD response will give a schematized series of metadata of the instance running the endpoint, such as NodeInfo schema version, software, protocols supported by the server, statistics and even a list of third-party services that can interact with the server via an API. Figure \label{NodeInfo response for mastodon.social} shows the NodeInfo 2.0 schema of the Mastodon instance mastodon.social. 

% \begin{lstlisting}[language=json, caption=NodeInfo response example, label=NodeInfo response example, float=H]
%   {
%       "links": [
%           {
%             "Rel": "http://nodeinfo.diaspora.software/ns/schema/2.1",
%               "href": "https://example.org/nodeinfo/2.1"
%           }
%       ]
%   }
% \end{lstlisting}

% \begin{lstlisting}[language=HTTP, caption=NodeInfo request]
%     GET /wel-known/nodeinfo/2.0 HTTP/1.1
%     Host: mastodon.social
% \end{lstlisting}

% \begin{lstlisting}[language=Json, caption=NodeInfo response for mastodon.social, label=NodeInfo response for mastodon.social, float=H]
% {
%    "version": "2.0",
%    "software": {
%        "name": "mastodon",
%        "version": "3.5.3"
%    },
%    "protocols": [
%        "activitypub"
%    ],
%    "services": {
%        "outbound": [],
%        "inbound": []
%    },
%    "usage": {
%        "users": {
%            "total": 718555,
%            "activeMonth": 61717,
%            "activeHalfyear": 178356
%        },
%        "localPosts": 36484017
%    },
%    "openRegistrations": true,
%    "metadata": []
% }
% \end{lstlisting}


\subsubsection{Web Host Metadata}
    Web host metadata is a lightweight metadata document format that allows for the identification of host policy or information, where "host" refers to the entity in charge of a collection of resources defined by URIs with a common URI host. It employs the XRD 1.0\footnote{https://docs.oasis-open.org/xri/xrd/v1.0/os/xrd-1.0-os.html} document format, which offers a basic and flexible XML-based schema for resource description. Moreover,  it provides two mechanisms for providing resource-specific information, specifically,  link templates and \emph{Link-based Resource Descriptor Documents} (LRDD). On the one hand, link templates require a URI in order to be a functioning link, thus avoiding the use of fixed URIs. On the other hand, the LRDD relation type is used to relate LRDD documents to resources or host-meta documents \cite{cook_2011}. In the specific case of the Mastodon implementation, as shown in \ref{host_metadata_response}, accessing the host-meta endpoint will give us back the "lrdd" link to the Webfinger endpoint. In which specific resource information can be found. 

\lstset{style=JSONStyle}
\begin{lstlisting}[language=PHP, caption=Host Medata request, label="Host Metadata request]
    GET /.well-known/host-meta HTTP/1.1
    Host: mastodon.social
    Accept: application/xrd+xml
\end{lstlisting}

\lstset{style=JSONStyle}
\begin{lstlisting}[language=XML, caption=Host metadata response from mastodon.social, label=host_metadata_response]
    <?xml version="1.0" encoding="UTF-8"?>
    <XRD xmlns="http://docs.oasis-open.org/ns/xri/xrd-1.0">
    <Link rel="lrdd" template="https://mastodon.social/.well-known/webfinger?resource={uri}"/>
    </XRD>
\end{lstlisting}

\subsubsection{Webfinger}
Finally, Webfinger is the protocol in which Mastodon heavily relies for the discovery process and for its normal functioning \cite{rochko_2020}. Webfinger allows for discovering information about persons or other entities on the Internet using HTTP that would not otherwise be useful as a locator, such as a personal profile address, identity service, telephone number or an email. Performing a query to a WebFinger endpoint requires a query component with a resource parameter, which is the URI that identifies the identity that is being looked up. Mastodon employs the \emph{acct}\footnote{https://datatracker.ietf.org/doc/html/rfc7565} URI format, which aims to offer a scheme that generically identifies a user's account with a service provider without requiring a specific protocol to be used when interacting with the account. In the same way NodeInfo works, it returns a JRD Document describing the entity \cite{jones_salgueiro_jones_smarr_2013}.  Fig. \label{Webfinger response from mastodon.social} shows an example of the returned JRD that is being provided by the WebFinger endpoint in the mastodon social instance when querying the account "acct:bob@mastodon.social".

\lstset{style=JSONStyle}
\begin{lstlisting}[language=PHP, caption=HTTP request to Webfinger endpoint, label=Webfinger request]
  GET /.well-known/webfinger?resource=acct:bob@mastodon.social
  Host: mastodon.social
  Accept: application/xrd+xml
\end{lstlisting}

\begin{lstlisting}[language=PHP, caption=Webfinger response, label=Webfinger response from mastodon.social]
{
   "subject": "acct:bob@mastodon.social",
   "aliases": [
       "https://mastodon.social/@bob",
       "https://mastodon.social/users/bob"
   ],
   "links": [
       {
           "rel": "http://webfinger.net/rel/profile-page",
           "type": "text/html",
           "href": "https://mastodon.social/@bob"
       },
       {
           "rel": "self",
           "type": "application/activity+json",
           "href": "https://mastodon.social/users/bob"
       },
       {
           "rel": "http://ostatus.org/schema/1.0/subscribe",
           "template": "https://mastodon.social/authorize_interaction?uri={uri}"
       }
   ]
}
\end{lstlisting}

\subsection{Security}

\subsubsection{HTTP Signature}

\subsubsection{JSON LD Signature}



\section{Decentralized Identifiers} \label{section:dids}

Globally unique identifiers are used by individuals, organizations, abstract entities, and even internet of things devices for all kinds of different contexts. Nonetheless, the large majority of these globally unique identifiers are not under the entity's control. We rely on external authorities to issue them, allowing them to decide who or what they refer to and when they can be revoked. Their existence, validity scope and even the security mechanisms that protect them are all dependent on these external authorities. Leaving their actual owners helpless against any kind of threat or misuse \cite{sporny_longley_sabadello_reed_steele_2021}. In order to address this lack of control, the W3C DID Working Group conceptualized the Decentralized Identifiers or \emph{DIDs}.

DIDs are a new type of globally unique identifier that enables individuals and organizations to create their own identifiers using trustworthy systems. By means of this, entities are able to prove control over them by authenticating using cryptographic proofs. Furthermore, given that the generation and assertion of DIDs are entity-controlled, an entity can create any number of DIDs that can be tailored and confined to specific contexts. This would enable interaction with other systems, institutions, or entities that require authentication while also limiting the amount of personal or private data to be revealed. All of this without the need to rely on a central authority \cite{sporny_longley_sabadello_reed_steele_2021}. To better illustrate how DIDs work, let's address the components which constitute DIDs. Figure \ref{fig:did_architecture} provides a basic overview of the major components of the Decentralized Identifier architecture.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{related_work/did_brief_architecture_overview.png}
  \caption{DID architecture overview \cite{sporny_longley_sabadello_reed_steele_2021}}
  \label{fig:did_architecture}
\end{figure}

\subsection{DID}  
The DID itself is a URI\footnote{https://www.rfc-editor.org/rfc/rfc3986} that consists of 3 different parts, namely the did URI scheme identifier, the method identifier and the DID method-specific identifier.

\begin{figure}[h]
  \centering
  \includegraphics[width=\textwidth]{related_work/parts-of-a-did.png}
  \caption{DID composition \cite{sporny_longley_sabadello_reed_steele_2021}}
  \label{fig:did}
\end{figure}

\subsection{DID URL}

A DID can include path, query and fragment in order to be able to locate a specific resource inside a DID document, as shown in \ref{fig:did_architecture}


\subsection{DID Subject}

Refers to the entity being identified by the DID. According to the specification \cite{sporny_longley_sabadello_reed_steele_2021}, any person, group, organization, physical thing, digital thing or logical thing can be a DID Subject.

\subsection{DID Controller}

The DID controller is the entity that can make changes to the DID Document. This entity is not necessarily the DID Subject itself.
  
\subsection{DID Document}

They contain information associated with a DID. They usually describe verification methods, such as cryptographic public keys, as well as services that are relevant to interactions with the DID Subject. An example of a DID Document can be seen in \ref{fig:did_document}.

\lstset{style=JSONStyle}
\begin{lstlisting}[language=PHP, caption=Example DID Document, label=fig:did_document]
{
  "@context": "https://w3id.org/did/v1",
  "id": "did:example:123456789abcdefghi",
  "publicKey": [{
    "id": "did:example:123456789abcdefghi#keys-1",
    "type": "RsaVerificationKey2018",
    "owner": "did:example:123456789abcdefghi",
    "publicKeyPem": "..."
  }],
  "authentication": [{
    "type": "RsaSignatureAuthentication2018",
    "publicKey": "did:example:123456789abcdefghi#keys-1"
  }],
  "service": [{
    "type": "ExampleService",
    "serviceEndpoint": "https://example.com/endpoint/8377464"
  }]
}

% \end{lstlisting}

The only required attribute for a DID Document is the ID. Other optional attributes include a controller, which specifies the DID Controller; verification methods, used to authenticate or authorize interactions with the DID subject or associated parties; and services, which can be any type of service the DID subject wants to advertise, including decentralized identity management services for further discovery, authentication, authorization, or interaction.
 

\subsection{DID methods}

DID methods describe the processes for CRUD operations for DIDs and DID documents, based on a specific type of verifiable data registry. Each DID method describes and implements its own security and privacy considerations. According to the DID registry of the W3C\footnote{https://www.w3.org/TR/did-spec-registries/\#did-methods}, there are around 130 registered DID methods. Based on their characteristics and patterns, the following 4-way classification of DIDs has arisen.

\begin{itemize}
  \item \textbf{Ledger-based DIDs}: This includes all the DIDs that store DIDs in a blockchain or other Distributed Ledger Technologies (DLTs). Examples include did:btcr, did:ethr and did:trx, whose DIDs are stored correspondingly in the Bitcoin, Ethereum and Tron network \cite{preukschat_reed_2021}.
  % \item \textbf{Ledger Middleware ("Layer 2") DIDs}: Broadly speaking, Layer 2 refers to a framework or protocol that is built on top of an existing blockchain system that takes the transactional burden away from layer 1 and post-finalized proofs back to layer 1. By removing this transaction load from layer 1, the base layer becomes less congested, and everything becomes more scalable [https://ethereum.org/en/layer-2/ ]. The Lightning Network ( \, LN	) \, is an example of a layer 2 Bitcoin protocol that offers users a fast micro-payment platform. Furthermore, regarding Layer 2 DID methods, the DIF has developed Sidetree\footnote{https://github.com/decentralized-identity/sidetree}. A protocol for creating scalable blockchain-agnostic Decentralized Identifier networks that enable users to create globally unique, user-controlled identifiers and manage their associated PKI metadata, without the need for centralized authorities or trusted third parties \cite{buchner_steele_ronda_2021}.
  Examples include: did:ion, did:elem.
  \item \textbf{Peer DIDs}: DIDs have the required ability to be resolvable, however not all of them have to be globally resolvable. The DIDs in this category do not exist on a global source of truth but in the context of relationships between peers in a limited number of participants. Nonetheless, their validity is not affected since they comply with the core properties and functionalities that a DID has to provide. 

  \item \textbf{Static DIDs}: This type of DIDs are limited in the kind of operations that can be performed on them. These DIDs are not stored in any registry, consequently, it is not possible to update, deactivate or rotate them. Using the did:key method as an example, the DID-method-specific part of the DID is encoded in a way that the DID document can be deterministically extracted from the DID itself \cite{longley_zagidulin_sporny_2022}.
\end{itemize}


did:ethr
This DID method was registered by Uport, an Ethereum-based system for self-sovereign identity \cite{Lundkvist_Heck_Torstensson_Mitton_Sena_2016}. It allows any Ethereum smart contract or key pair account, or any secp256k1 public key to becoming a valid identifier \cite{nistor_grassberger_carlin_2022}. UPort is a smart-contract-based system that abstracts user accounts using proxy contracts that are held by the user but may be retrieved if keys are lost. To do this, controller contracts create trusted entities for asserting ownership \cite{8783188}


did:ens:
% The Ethereum Name Service (ENS) is a distributed, open, and extensible naming system based on the Ethereum blockchain. Its purpose is to map names like 'bob.eth' into machine-readable identifiers like Ethereum addresses, other cryptocurrency addresses, content hashes, and metadata. In the same way the Domain Name System (DNS) maps human-readable domains like 'google.com' to IP addresses. However, their architecture differs due to the capabilities and constraints of the Ethereum blockchain. (https://github.com/veramolabs/did-ens-spec )
% This DID method was registered by Consensys, a blockchain venture studio founded by Ethereum's cofounder Joseph Lubin that supports Ethereum-based projects. Some of these projects include uPort, Metamask, Civil, Truffle and Gnosis. [https://decrypt.co/resources/consensys]. 


% This DID method was created with the following objectives, firstly to integrate ENS names to be interoperable with applications that implement DIDs, and secondly, to add DID-capabilities to ENS names such as services and verification methods [https://github.com/veramolabs/did-ens-spec].

% did:ion:
% This DID method works by registering DIDs to the Bitcoin network. Launched to the public in March 2021, Identity Overlay Network (ION) is Microsoft's DID-network built on top of the Bitcoin Network implemented using Sidetree (https://techcommunity.microsoft.com/t5/identity-standards-blog/ion-we-have-liftoff/ba-p/1441555 ). 
% ION is public, permissionless, it does not implement its own currency and its nodes do not require an additional consensus mechanism. (https://github.com/decentralized-identity/ion ).

\subsection{Verifiable Data Registry}

Essentially, any system that enables capturing DIDs and returning required data to generate DID documents. This can be distributed ledgers, decentralized file systems, any type of database, peer-to-peer networks, or other types of trustworthy data storage \cite{sporny_longley_sabadello_reed_steele_2021}.

\subsection{DID resolver}

A DID resolver is able to implement the DID resolution, which consists of taking a DID as an input, and giving a DID Document as an output \cite{sporny_longley_sabadello_reed_steele_2021}. As of the writing of this thesis, the Identifiers \& Discovery Working Group (ID WG) has implemented a prototype Universal Resolver\footnote{https://github.com/decentralized-identity/universal-resolver}, which allows the resolution of DIDs for numerous DID methods, including all the examples mentioned above. In addition, this working group has also developed a Universal Registrar\footnote{https://uniregistrar.io/}, which allows the creation, edition and deactivation of the DIDs across different DID methods.

% Comparing DIDs with other identifiers


% UUID Universally Unique Identifiers: 
% UUIDs are similar to DIDs, because they do not require a centralized registration authority. But they are not resolvable or cryptographically-verifiable. 


% Almost all types of identifier systems can support DIDs. This would create an interoperability bridge between centralized, federated and decentralized worlds. Implementers can use any kind of computing infrastructure they trust, such as distributed ledgers, decentralized file systems, distributed databases or peer-to-peer networks. 


% Services
% Services are used to specify ways to communicate with the DID subject. Services can be decentralized identity management for further discovery, authentication, authorization or interaction. 


% DID Privacy 

% The 7 Principles of Privacy by design have been applied to DIDs. (https://iapp.org/media/pdf/resource_center/pbd_implement_7found_principles.pdf )






%  A DID is unlikely to contain any information about the DID subject, so further information about the DID subject is only discoverable by resolving the DID to the DID document, obtaining a verifiable credential about the DID, or via some other description of the DID.



\section{DIDComm Messaging}\label{section:didcomm}

\subsection{Definition}

The Hyperledger Foundation is an open-source collaborative effort intended to further develop blockchain technologies across industries \cite{jones_boswell_2022}. Started in 2016 by the Linux Foundation, it has given birth to numerous enterprise-grade software open-source projects that can be classified into DLTs, libraries, tools and labs \cite{lusard_lehors_muscara_boswell_zsigri_2021}. One of these graduate projects is Hyperledger Aries, which together with Hyperledger Indy (HI) and Hyperledger Ursa (HU), makes up the Sovereign Identity Blockchain Solutions of Hyperledger. HI supplies a distributed ledger specifically built for decentralized identity, HU is a shared cryptography library that helps to avoid duplicating cryptographic work across projects while also potentially increasing security. Finally, Aries provides solutions for SSI-based identity management, including key management, credential management, and an encrypted, peer-to-peer DID-based messaging system that is now labeled as Didcomm v1 \cite{jones_boswell_2022}. 
Based on Didcomm v1, the Communication Working Group (CWG) of the DIF has implemented DIDcomm v2. Among other key differences between versions, such as formalizations of Didcomm v1 methods, Didcomm v2 has removed the special handling of Peer-DIDs in order to make all DIDs equal from the perspective of the DIDComm spec. Furthermore, the CWG pursues the standardization of DIDcomm not only to widen its implementation beyond Aries-based projects but to create an interoperable layer that would allow higher-order protocols to build upon its security, privacy, decentralization, and transport independence in the same way web services build upon HTTP. \cite{young_2020} \cite{curren_looker_terbu_2020}

From this point on, we are going to refer to DIDComm Messaging v2 only as DIDComm. Didcomm can be described as a communication protocol that promises a secure and private methodology that builds on top of the decentralized design of DIDs. Moreover, Didcomm is a very versatile protocol, as it supports a wide range of features, such as security, privacy, decentralization, routable, interoperability, and the ability to be transport-agnostic \cite{curren_looker_terbu_2020}.

To better understand how it works, let's look at how it would work in a scenario where Alice wants to send a private message to Bob: 


% \begin{algorithm}[H]
% \caption{Example of DID communication using DIDComm \cite{Abramson_2020}}
% \label{alg:didcomm_example}
%   \begin{algorithmic}[1]
%     \State Alice has a private key \emph{sk\textsubscript{a}} and a DID Document for Bob containing an endpoint \emph{(endpoint\textsubscript{bob})} and a public key \emph{(pk\textsubscript{b})}.

%     \State Bob has a private key \emph{sk\textsubscript{b}} and a DID Document for Alice containing her public key \emph{(pk\textsubscript{a})}.

%     \State Alice encrypts plaintext message \emph{(m)} using pk\textsubscript{b} and creates an encrypted message \emph{(eb)}.

%     \State Alice signs eb using her private key \emph{sk\textsubscript{a}} and creates a signature \emph{(s)}.

%     \State Alice sends \emph{(eb, s)} to \emph{endpoint\textsubscript{bob}}.

%     \State Bob receives the message from Alice at \emph{{endpoint\textsubscript{bob}}.}

%     \State Bob verifies \emph{(s)} using Alice's public key \emph{pk\textsubscript{a}}

%     \If{Verify \emph{(eb, s, pk\textsubscript{a})} = 1}
%     \State Bob decrypts \emph{eb} using \emph{sk\textsubscript{b}}.
%     \State Bob reads the plaintext message \emph{(m)} sent by Alice
%     \EndIf
%   \end{algorithmic}
% \end{algorithm}


% [https://arxiv.org/pdf/2006.02456.pdf ]

DIDComm differs from the current dominant web paradigm, where something as simple as an API call requires an almost immediate response through the same channel from the receiving end. This duplex request-response interaction is, however, not always possible as many agents may not have a constant network connection or may interact only in larger time frames, or may even not listen over the same channel where the original message was sent. DIDComm's paradigm is asynchronous and \emph{simplex}. Thus showing a bigger resemblance with the email paradigm. Furthermore, the web paradigm goes under the assumption that traditional methods for processes like authentication, session management, and end-to-end encryption are being used. Didcomm does not require certificates from external parties to establish trust, nor does it require constant connections for end-to-end transport-level encryption (TLS). Taking the security and privacy responsibility away from institutions and placing it with the agents. All of this without limiting the communication possibilities because of its ability to function as a base layer where opposed capabilities like sessions and synchronous interactions can be built upon. \cite{curren_looker_terbu_2020}

To achieve the encryption and signing processes mentioned in algorithm \ref{alg:didcomm_example}, Didcomm implements a family of the Internet Engineering Task Force (IETF) standards, collectively called JSON Object Signing and Encryption (JOSE), which will be further explained in the next section. 

\subsection{JOSE Family}

This RFC family includes both the JSON Web Signature (JWS) and the JSON Web Encryption (JWE) standards that are subclasses of the JSON Web Token (JWT), and JSON Web Key (JWK).


The second part of the DIDComm enablement, namely the signing and encrypting, will depend on what kind of security guarantees we want to achieve. DIDComm offers different approaches based on signing and two types of message encryption. Authenticated Sender Encryption (\emph{authcrypt}) and Anonymous Sender Encryption (\emph{anoncrypt}) are both encrypted and delivered to the recipient's DID. Still, they differ because only \emph{authcrypt} gives direct guarantees about the sender's identity. Sending anonymous messages in social networks is not usually the case, and removing the attribution of a post can lead to other problems \cite{martin_2022}. However, social networks like Ask.fm\footnote{https//ask.fm} or NGL\footnote{https://ask.fun} that rely on anonymous posts could use the advantages of \emph{anoncrypt}.

DIDComm recommends using \emph{authcrypt} as the standard to provide confidentiality, message integrity, and authenticity of the sender. For this, \emph{authcrypt} requires the public key authenticated encryption algorithm \emph{ECDH-1PU}\footnote{https://datatracker.ietf.org/doc/html/draft-madden-jose-ecdh-1pu-04}. This algorithm j

This is due to the use of the 
Elliptic-curve Diffie\-Hellman (ECDH) protocol, which allows two parties to build a secure and private channel across an insecure and observable network. This protocol is part of the foundation of popular messaging apps such as Facebook Messenger, Whatsapp, Signal, and Didcomm V1 \cite{shaaban_2021}. This key agreement protocol works by having both parties interchanging the public keys of their EC keypairs and some other public information. Using this public data and their private keys both parties can calculate a shared secret value, which it's the same for both parties. Any other observer or third party is not able to compute this shared secret without the private data \cite{5972416}. 

An alternative to \emph{Authcrypt} that also complies with the required confidentiality and non-repudiation requirements is to have a nested JWT. To achieve this, the plaintext is first signed and then the resulting JWS is used as the payload of a JWE. The algorithm \ref{alg:nested_jwt} illustrates better the workings of this. 

\begin{algorithm}[H]
  \caption{Communication example with nested JWT}
  \label{alg:nested_jwt}
    \begin{algorithmic}[1]
      \State Alice signs a plain text message using her private key \emph{sk\textsubscript{a}} and creates a \emph{(jws)}.
  
      \State Alice encrypts the \emph{(jws)} using Bob's public key pk\textsubscript{b} and creates a \emph{(jwe)}.
  
      \State Alice sends \emph{jwe} to Bob.
  
      \State Bob decrypts \emph{(jwe)} using his private key \emph{sk\textsubscript{b}} and obtains the \emph{jws}
      \State Bob verifies \emph{(jws)} using Alice's public key \emph{pk\textsubscript{a}}
  \end{algorithmic}
\end{algorithm}
  
In both alternatives, the identity of the sender can be confirmed and the plain text message remains encrypted and hidden from any third party that might manage to read the payload. As mentioned in \autoref{section:didcomm}, the JWE can be sent through any unprotected protocol and still keep all of its advantages. 



Compare with other encryption methods. (TLS, Whatsapp end-to-end, Signal) (Use image below)
 